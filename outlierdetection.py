# -*- coding: utf-8 -*-
"""OutlierDetection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cVqYoPwUCT9Kf8HCJFW76ZWWdEgHozvy
"""

'''
In data science handling outliers in the data is very tricky task.It always depends upon domain knowledge , data knowledge and also on the count of outliers as well.
Since 'How do you handle outliers?' is very data specific question there is no hard and fast rule to handle the outliers.
'''
#consider the following dataset. We can clearly see 300 and 400 are the outliers present in each
import pandas as pd

df = pd.DataFrame({
    
    'w':['a','b','c','d','e','a','b','c','d','e'],
    'x':[1,2,3,4,300,400,36,45,71,21],
    'y': [300,400,3,4,5,6,23,35,54,90],
    'z':[1,2,300,400,5,6,55,45,26,45]
    
    
})

'''
if((pd.to_numeric(df[column_name].dropna(),errors='coerce').isna().sum()< 0.7*len(df[column_name])))
this code line in below function handles a column in following way:

1)If any continuos column has any error data i.e string in it,then  ' pd.to_numeric(df[column_name].dropna(),errors='coerce') ' this line will replace 
any string data in continuous column with NA.

2)Then it will check if number of NAs in a columns is less than 70 percent of the length of that column , if they are more than 70 percent then that column has 
 data of type - 1,2,3,4,w,d,a,b,b,c if this is the case then that column will not be handled as it requires additional preprocessing before removing outliers.
 But if the data is of type - 1,2,3,4,5,6,7,8,a,b then most of the entries here are countinuous and number of NA introduced after typecasting to numeric will be 2
 i.e. 20 percent so outliers in this columns will be handled.
 This is due to we are ignoring some percentage of nnoise present in a column but not above threshold value
'''

def remove_outliers(df,rmv_out):
  for column_name in df.columns:
    if(pd.to_numeric(df[column_name].dropna(),errors='coerce').isna().sum()< 0.3*len(df[column_name])):
      outliers=[]
      '''
      Technique used below to find outliers is IQR(Inter Quantile Range) Score.
      '''
      q1,q3=df[column_name].quantile([0.25,0.75])
      IQR=q3-q1
      upper_limit=q3+(1.5*IQR)
      lower_limit=q1-(1.5*IQR)
      if rmv_out==False:
         df[column_name]=df[column_name].apply(lambda x:df[column_name].median() if x<lower_limit or x>upper_limit else x)      
     
      else:
        out=df[column_name].apply(lambda x: x if x<lower_limit or x>upper_limit else None)
        df=df[df[column_name]!=out]
        

  return df

'''
rmv_out is a parameter in the function , setting it as True will remove rows containing outliers, setting it as false will replace outlier entry
with median of that column.
To completely remove outliers we may need to execute below line twice or thrice with rmv_out=True because that is how this IQR method works ,
range/quantiles gets changed after every function call
'''

df=remove_outliers(df,rmv_out=True)
print(df)