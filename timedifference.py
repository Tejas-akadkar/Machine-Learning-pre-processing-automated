# -*- coding: utf-8 -*-
"""TimeDifference.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YdZBRkwWsT9gael5U-nQpqBFW_iQPfJT
"""

import pandas as pd
import numpy as np
import datetime
df = pd.DataFrame({
    
    
    'd1':['10:00:00','11:00:00','12:00:00','12:00:00','00:00:00','abc'],
    'd2': ['15:00:00','14:00:00','17:00:00','17:00:00','19:00:00','19:00:00'],
    'd3':['10:00:00','11:00:00','12:00:00','13:00:00','14:00:00','abc'],
    'd4':[1,2,300,400,5,6],
    'd5':['a','b','c','d','e','f']
    
})

df['d4'].dtype

def time_diff(df):
  time_col_names=[]
  for col_name in df.columns:
    '''
    df[col_name].dtype!='int64
    this condition is to ignore continuos columns in dataset as in dataset above d4 is the continuos column
    '''
    if(df[col_name].dtype=='float64' or df[col_name].dtype=='int64'):
      pass
    
    elif(pd.to_timedelta(df[col_name],errors='coerce').isnull().sum()< 0.7* len(df[col_name])):
      '''
    elif(pd.to_timedelta(df[col_name],errors='coerce').isnull().sum()< 0.7* len(df[col_name]))
    this handles the column where date and other objects both are present in a column , logic is same as that of outlier program logic
    ''' 
      df[col_name]=pd.to_timedelta(df[col_name],errors='coerce')
      '''
      time_col_names.append(col_name)
      this is adding all those column names which have date data type for futher calculations
      '''
      time_col_names.append(col_name)
  time_data = df[np.intersect1d(df.columns, time_col_names)]
  for col1 in time_col_names:
    
    for col2 in time_col_names:
      '''
      if time_col_names.index(col2) > time_col_names.index(col1)
      this is to avoid duplicate multiplications
      for ex. once we calculate d1-d2 we do not want to calculate d2-d1 
      if we want to keep d1-d2 and d2-d1 both then we can remove this line
      '''
      if time_col_names.index(col2) > time_col_names.index(col1):
        new_col_name=col1+'-'+ col2
        df[new_col_name]=time_data.apply(lambda x: x[col1]-x[col2],axis=1)
  return df


df=time_diff(df)
df