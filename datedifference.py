# -*- coding: utf-8 -*-
"""DateDifference.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-S3M758Vz3luCwqaLyJ1faFK7_y4s8nB
"""

import pandas as pd
import numpy as np
from datetime import datetime
df = pd.DataFrame({
    
    
    'd1':['10/10/2020','10/10/2020','10/10/2020','abc',np.nan],
    'd2': ['2020/10/10','2020/1/1','2020/2/2','2020/10/15','2020/10/10'],
    'd3':['1 January 2020','15 June 2019','3 July 2018','31 December 2016','21 February 2020'],
    'd4':['12/25/2020','11/25/2020','5/25/2020','3/25/2020','10/25/2020'],   
    'd6':[1,2,300,400,5],
    'd7':['a','b','c','e','f']
    
})

'''
cases handled
dd/mm/yyyy
yyyy/mm/dd
1 Jan 2020, 1 January 2020
mm/dd/yyyy
'''
def date_diff(df):
  datecol=[]
  for col in df.columns:
    if df[col].dtype == 'object':
      '''
if(pd.to_datetime(df[col],errors='coerce').isna().sum()< 0.7*len(df[col])):
this code line in below function handles a column in following way:

1)If any non date column has any error data i.e categorical or continuous number in it,then  ' (pd.to_datetime(df[col],errors='coerce') ' this line will replace 
any string/categorical data in date column with NA.

2)Then it will check if number of NAs in a columns is less than 70 percent of the length of that column , if they are more than 70 percent then that column has 
 data of type :- 12/25/2020,12/25/2020,12/25/2020,12/25/2020,w,d,a,b,b,c if this is the case then that column will not be handled 
 as it requires additional preprocessing.But if the data is of type - 12/25/2020,12/25/2020,12/25/2020,12/25/2020,5,12/25/2020,12/25/2020,12/25/2020,a,b then most
 of the entries here are not of type date and number of NA introduced after typecasting to numeric will be 2 i.e. 20 percent so outliers in this columns will be handled.
      This is due to we are ignoring some percentage of nnoise present in a column but not above threshold value
      '''

      if(pd.to_datetime(df[col],errors='coerce').isna().sum()< 0.3*len(df[col])):
        df[col]=pd.to_datetime(df[col],errors='coerce')
        datecol.append(col)
  date_data = df[np.intersect1d(df.columns, datecol)]
  for col1 in datecol:    
    for col2 in datecol:
      if datecol.index(col2) > datecol.index(col1):
        '''
      if time_col_names.index(col2) > time_col_names.index(col1)
      this is to avoid duplicate multiplications
      for ex. once we calculate d1-d2 we do not want to calculate d2-d1 
      if we want to keep d1-d2 and d2-d1 both then we can remove this line
      '''
        new_col_name=col1+'-'+ col2 #this is just constructing a appropiate name for the column 
        
        df[new_col_name]=date_data.apply(lambda x: 'NaT' if (pd.isnull((x[col1]-x[col2]))) else abs(x[col1]-x[col2]),axis=1)
  
  return df
     
df=date_diff(df)
df

